# Guía de Pruebas y Optimización

**Proyecto:** QuickStay - Plataforma de Alquiler Express
**Módulo:** Administración de Sistemas Informáticos en Red (ASIR)
**Autor:** Antonio López Montes
**Fecha:** 23 de Diciembre de 2025

---

## 1. Pruebas de Failover Exhaustivas

Las pruebas de *failover* son cruciales para validar la capacidad de la infraestructura de QuickStay para mantener la disponibilidad del servicio ante fallos de componentes críticos. Se simularán fallos controlados y se verificará la recuperación automática o manual.

### 1.1. Balanceador de Carga

| Escenario de Prueba | Pasos | Criterio de Éxito |
| :--- | :--- | :--- |
| **Fallo de Servidor Web** | 1. Acceder a la aplicación web a través de la VIP del balanceador. 2. Apagar `webserver1`. 3. Intentar acceder de nuevo a la aplicación. | El tráfico debe ser redirigido automáticamente a `webserver2` sin interrupción del servicio. La aplicación debe seguir siendo accesible. |
| **Recuperación de Servidor Web** | 1. Encender `webserver1`. 2. Verificar que el balanceador lo reincorpora al *pool*. | `webserver1` debe volver a recibir tráfico del balanceador una vez que esté operativo y pase los *health checks*. |

### 1.2. Base de Datos MySQL

| Escenario de Prueba | Pasos | Criterio de Éxito |
| :--- | :--- | :--- |
| **Fallo de MySQL Master** | 1. Verificar la replicación entre `db1` (Master) y `db2` (Slave). 2. Detener el servicio MySQL en `db1`. 3. Promocionar `db2` a Master. 4. Verificar que la aplicación puede conectarse al nuevo Master. | `db2` debe ser promocionado a Master y la aplicación debe poder realizar operaciones de lectura/escritura en él. La pérdida de datos debe ser mínima (RPO < 1h). |
| **Recuperación de MySQL Master** | 1. Reparar `db1`. 2. Configurar `db1` como Slave del nuevo Master (`db2`). 3. Verificar la replicación. | `db1` debe sincronizarse con `db2` y estar listo para una futura promoción si es necesario. |

### 1.3. Active Directory

| Escenario de Prueba | Pasos | Criterio de Éxito |
| :--- | :--- | :--- |
| **Fallo de AD-DC Primario** | 1. Verificar la autenticación de usuarios en el dominio. 2. Apagar `dc1.quickstay.local`. 3. Intentar autenticar un usuario. | La autenticación debe seguir funcionando sin interrupciones a través de `dc2.quickstay.local`. |
| **Recuperación de AD-DC Primario** | 1. Encender `dc1.quickstay.local`. 2. Verificar la replicación de AD y SYSVOL entre `dc1` y `dc2`. | `dc1` debe sincronizarse con `dc2` y ambos deben funcionar como Controladores de Dominio redundantes. |

### 1.4. Infraestructura IoT

| Escenario de Prueba | Pasos | Criterio de Éxito |
| :--- | :--- | :--- |
| **Fallo de Gateway MQTT Primario** | 1. Verificar la comunicación de un dispositivo IoT con `iotgateway1`. 2. Detener el servicio Mosquitto en `iotgateway1`. 3. Verificar que el dispositivo IoT se conecta automáticamente a `iotgateway2`. | El dispositivo IoT debe reconectarse al *broker* secundario (`iotgateway2`) y continuar la comunicación sin pérdida significativa de mensajes. |
| **Recuperación de Gateway MQTT Primario** | 1. Encender `iotgateway1`. 2. Verificar que los dispositivos IoT pueden volver a conectarse a él o que el *heartbeat* lo reincorpora. | `iotgateway1` debe estar operativo y listo para aceptar conexiones de dispositivos IoT. |

---

## 2. Pruebas de Rendimiento

Las pruebas de rendimiento evaluarán la capacidad de la infraestructura para manejar diferentes niveles de carga de usuarios, identificando posibles cuellos de botella y asegurando que la plataforma QuickStay puede escalar según las necesidades.

### 2.1. Simulación de Carga

Se utilizarán herramientas de simulación de carga (ej. Apache JMeter, Locust) para simular usuarios concurrentes realizando operaciones típicas de la aplicación (búsqueda, reserva, pago).

| Escenario de Carga | Usuarios Concurrentes | Duración | Operaciones Clave |
| :--- | :--- | :--- | :--- |
| **Carga Baja** | `10` | `15 minutos` | Búsqueda de propiedades, visualización de detalles. |
| **Carga Media** | `50` | `30 minutos` | Búsqueda, reserva, login/logout. |
| **Carga Alta** | `100` | `60 minutos` | Búsqueda, reserva, pago, actualización de perfil. |

### 2.2. Análisis de Tiempos de Respuesta

Se medirán los tiempos de respuesta de las transacciones clave bajo diferentes cargas para asegurar que cumplen con los SLAs definidos.

| Transacción | SLA Objetivo | Herramienta de Medición | Criterio de Éxito |
| :--- | :--- | :--- | :--- |
| **Búsqueda de Propiedades** | `< 500 ms` | JMeter/Locust | El 95% de las peticiones deben estar por debajo del SLA. |
| **Realizar Reserva** | `< 1000 ms` | JMeter/Locust | El 95% de las peticiones deben estar por debajo del SLA. |
| **Procesar Pago** | `< 2000 ms` | JMeter/Locust | El 95% de las peticiones deben estar por debajo del SLA. |

### 2.3. Monitorización de Recursos

Durante las pruebas de carga, se monitorizarán los recursos de los servidores (CPU, RAM, Disco, Red) utilizando Zabbix para identificar el uso y la saturación.

| Recurso | Métrica Clave | Umbral de Alerta | Herramienta |
| :--- | :--- | :--- | :--- |
| **CPU** | `% de Uso` | `> 80%` | Zabbix |
| **RAM** | `% de Uso` | `> 90%` | Zabbix |
| **Disco** | `IOPS, Latencia` | `> 500 IOPS, > 20 ms` | Zabbix |
| **Red** | `Ancho de Banda` | `> 80% de capacidad` | Zabbix |

### 2.4. Identificación de Cuellos de Botella

Se analizarán los resultados de las pruebas y la monitorización para identificar componentes que limitan el rendimiento (ej. consultas lentas en BD, código ineficiente en la aplicación, saturación de red).

---

## 3. Ajustes y Optimizaciones

Basado en los resultados de las pruebas de failover y rendimiento, se realizarán ajustes y optimizaciones en la configuración de la infraestructura y la aplicación para mejorar la estabilidad, el rendimiento y la eficiencia.

### 3.1. Tuning de Servicios Basado en Pruebas

| Servicio | Ajuste Potencial | Justificación |
| :--- | :--- | :--- |
| **Servidor Web (Apache/Nginx)** | Ajustar número de *workers*, *keepalive_timeout*. | Optimizar el manejo de conexiones concurrentes. |
| **Servidor de Aplicación (Tomcat/WildFly)** | Ajustar *memory heap* (JVM), *thread pools*. | Mejorar el rendimiento de la aplicación Java. |
| **Base de Datos (MySQL)** | Ajustar `innodb_buffer_pool_size`, `query_cache_size`. | Optimizar el uso de memoria y caché para consultas. |

### 3.2. Ajuste de Timeouts y Conexiones

Se revisarán y ajustarán los *timeouts* de conexión y lectura en el balanceador de carga, servidores de aplicación y base de datos para prevenir conexiones colgadas y mejorar la resiliencia.

### 3.3. Optimización de Consultas BD

Se identificarán y optimizarán las consultas SQL lentas mediante la adición de índices, reescritura de consultas o refactorización del esquema de la base de datos.

### 3.4. Cache Configuration

Se implementarán o ajustarán mecanismos de caché a diferentes niveles (ej. caché de navegador, caché de aplicación, caché de base de datos) para reducir la carga en los servidores y mejorar los tiempos de respuesta.
